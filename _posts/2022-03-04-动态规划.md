---
layout: post
title: 2022-03-04-动态规划
tags: [leetcode,面试]
category: leetcode
toc: true
math: true
author: zzhc
---

### 方法论
1. 确定dp数组(dp table)以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组


***
<br>

<br>


### 746. 使用最小花费爬楼梯

**给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。**


#### 思路

-  dp[i]的定义：到达第i个台阶所花费的最少体⼒为dp[i]；
-  可以有两个途径得到dp[i]，⼀个是dp[i-1] ⼀个是dp[i-2]，dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
-  看⼀下递归公式，dp[i]由dp[i-1]，dp[i-2]推出，既然初始化所有的dp[i]是不可能的，那么只初始化dp[0]和dp[1]就够了，其他的最终都是dp[0]dp[1]推出；
-  从前到后遍历cost数组就可以了；



```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:

        n = len(cost)
        if n==1:
            return cost[0]
        dp = [0 for i in range(len(cost))]
        dp[0] = cost[0]
        dp[1] = cost[1]

        for i in range(2,n):
            dp[i] = min(dp[i-1], dp[i-2]) + cost[i]

        return min(dp[-1],dp[-2])
```

优化：

```python 
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:

        n = len(cost)
        if n==1:
            return cost[0]
        dp0 = cost[0]
        dp1 = cost[1]

        for i in range(2,n):
            dpi = min(dp0, dp1) + cost[i]
            dp0 = dp1
            dp1 = dpi

        return min(dp0,dp1)
```



***
<br>

<br>




### 329. 矩阵中的最长递增路径

**strong text**


#### 思路









***
<br>

<br>







### 329. 矩阵中的最长递增路径

**strong text**


#### 思路









***
<br>

<br>